<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鱼小鱼别皱眉</title>
  
  <subtitle>我思故我在</subtitle>
  <link href="https://serenitylc.github.io/atom.xml" rel="self"/>
  
  <link href="https://serenitylc.github.io/"/>
  <updated>2022-08-02T15:25:32.992Z</updated>
  <id>https://serenitylc.github.io/</id>
  
  <author>
    <name>serenitylc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有限状态机</title>
    <link href="https://serenitylc.github.io/2022/08/01/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>https://serenitylc.github.io/2022/08/01/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2022-07-31T16:00:00.000Z</published>
    <updated>2022-08-02T15:25:32.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有限状态机，一种抽象的理论模型。"><a href="#有限状态机，一种抽象的理论模型。" class="headerlink" title="有限状态机，一种抽象的理论模型。"></a>有限状态机，一种抽象的理论模型。</h2><p>有限状态机(Finite State Machine)通过可构造、可验证的方式来呈现有限个变量所描述的状态变化过程。比如，封闭的有向图。它可以通过<code>if-else, switch-case</code>和函数指针来实现，从软件工程角度看，主要是为了封装逻辑。</p><p>带有状态转移的有限状态机示例:</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">STATE_MACHINE() &#123;</span><br><span class="line">    State cur_State = type_A;</span><br><span class="line">    <span class="keyword">while</span> (cur_State != type_C) &#123;</span><br><span class="line">        Package <span class="variable">_pack</span> = getNewPackage();</span><br><span class="line">        <span class="keyword">switch</span>() &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                process_pkg_state_A(<span class="variable">_pack</span>);</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                process_pkg_state_B(<span class="variable">_pack</span>);</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该状态机包含三种状态：type_A，type_B和type_C。其中，type_A是初始状态，type_C是结束状态。状态机的当前状态记录在cur_State变量中，逻辑处理时，状态机先通过getNewPackage获取数据包，然后根据当前状态对数据进行处理，处理完后，状态机通过改变cur_State完成状态转移。</p><p>有限状态机是一种逻辑单元内部的高效编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂。</p><h2 id="Web服务器中，基于状态机来处理http报文"><a href="#Web服务器中，基于状态机来处理http报文" class="headerlink" title="Web服务器中，基于状态机来处理http报文"></a>Web服务器中，基于状态机来处理http报文</h2><p>http报文处理流程：</p><ul><li>浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。</li><li>工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。</li><li>解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。</li></ul><p><img src="/pic/images/state.png" alt="示例"></p><p>定义http类</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">http_conn</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 设置读取文件的名称m_real_file大小</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> FILENAME_LEN=<span class="number">200</span>;</span><br><span class="line">        <span class="comment">// 设置读缓冲区m_read_buf大小</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> READ_BUFFER_SIZE=<span class="number">2048</span>;</span><br><span class="line">        <span class="comment">// 设置写缓冲区m_write_buf大小</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> WRITE_BUFFER_SIZE=<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 报文的请求方法</span></span><br><span class="line">        <span class="built_in">enum</span> METHOD&#123;GET=<span class="number">0</span>, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT, PATH&#125;;</span><br><span class="line">        <span class="comment">// 主状态机的状态</span></span><br><span class="line">        <span class="built_in">enum</span> CHECK_STATE&#123;CHECK_STATE_REQUESTLINE=<span class="number">0</span>, CHECK_STATE_HEADER, CHECK_STATE_CONTENT&#125;;</span><br><span class="line">        <span class="comment">// 报文解析的结果</span></span><br><span class="line">        <span class="built_in">enum</span> HTTP_CODE &#123;NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION&#125;;</span><br><span class="line">        <span class="comment">//从状态机的状态</span></span><br><span class="line">        <span class="built_in">enum</span> LINE_STATUS&#123;LINE_OK=<span class="number">0</span>, LINE_BAD, LINE_OPEN&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        http_conn()&#123;&#125;</span><br><span class="line">        ~http_conn()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 初始化套接字地址，函数内部会调用私有方法init</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span>(<span class="params"><span class="built_in">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;addr</span>)</span>;</span><br><span class="line">        <span class="comment">// 关闭http连接</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">close_conn</span>(<span class="params"><span class="built_in">bool</span> real_close = <span class="literal">true</span></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span>()</span>;</span><br><span class="line">        <span class="comment">// 读取浏览器端发来的全部数据</span></span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">read_once</span>()</span>;</span><br><span class="line">        <span class="comment">// 响应报文写入函数</span></span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">write</span>()</span>;</span><br><span class="line">        sockaddr_in *get_address() &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;m_address;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步线程初始化数据库读取表</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initmysql_result</span>()</span>;</span><br><span class="line">        <span class="comment">// CGI使用线程池初始化数据库表</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initresultFile</span>(<span class="params">connection_pool *connPool</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span>()</span>;</span><br><span class="line">        <span class="comment">// 从m_read_buf读取，并处理请求报文</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">process_read</span>()</span>;</span><br><span class="line">        <span class="comment">// 向m_write_buf写入响应报文数据</span></span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">process_write</span>(<span class="params">HTTP_CODE ret</span>)</span>;</span><br><span class="line">        <span class="comment">// 主状态机解析报文中的请求行数据</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">parse_request_line</span>(<span class="params"><span class="built_in">char</span> *text</span>)</span>;</span><br><span class="line">        <span class="comment">// 主状态机解析报文中的请求头数据</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">parse_headers</span>(<span class="params"><span class="built_in">char</span> *text</span>)</span>;</span><br><span class="line">        <span class="comment">// 主状态机解析报文中的请求内容</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">parse_content</span>(<span class="params"><span class="built_in">char</span> *text</span>)</span>;</span><br><span class="line">        <span class="comment">// 生成响应报文</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">do_request</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m_start_line是已经解析的字符</span></span><br><span class="line">        <span class="comment">// get_line用于将指针向后偏移，指向未处理的字符</span></span><br><span class="line">        <span class="built_in">char</span>* get_line() &#123; <span class="keyword">return</span> m_read_buf + m_start_line; &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从状态机读取一行，分析是请求报文的哪一部分</span></span><br><span class="line">        <span class="function">LINE_STATUS <span class="title">parse_line</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unmap</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据响应报文格式，生成对应8个部分，以下函数均由do_request调用</span></span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_response</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span>* format, ...</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_content</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span>* content</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_status_line</span>(<span class="params"><span class="built_in">int</span> status, <span class="keyword">const</span> <span class="built_in">char</span>* title</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_headers</span>(<span class="params"><span class="built_in">int</span> content_length</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_content_type</span>()</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_content_length</span>(<span class="params"><span class="built_in">int</span> content_length</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_linger</span>()</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bool</span> <span class="title">add_blank_line</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> m_epollfd;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> m_user_count;</span><br><span class="line">        MYSQL *mysql;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">int</span> m_sockfd;</span><br><span class="line">        sockaddr_in m_address;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储读取的请求报文数据</span></span><br><span class="line">        <span class="built_in">char</span> m_read_buf[READ_BUFFER_SIZE];</span><br><span class="line">        <span class="comment">// 缓冲区中m_read_buf中数据的最后一个字节的下一个位置</span></span><br><span class="line">        <span class="built_in">int</span> m_read_idx;</span><br><span class="line">        <span class="comment">// m_read_buf读取的位置m_checked_idx</span></span><br><span class="line">        <span class="built_in">int</span> m_checked_idx;</span><br><span class="line">        <span class="comment">// m_read_buf中已经解析的字符个数</span></span><br><span class="line">        <span class="built_in">int</span> m_start_line;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储发出的响应报文数据</span></span><br><span class="line">        <span class="built_in">char</span> m_write_buf[WRITE_BUFFER_SIZE];</span><br><span class="line">        <span class="comment">// 指示buffer中的长度</span></span><br><span class="line">        <span class="built_in">int</span> m_write_idx;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主状态机的状态</span></span><br><span class="line">        CHECK_STATE m_check_state;</span><br><span class="line">        <span class="comment">// 请求方法</span></span><br><span class="line">        METHOD m_method;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下为解析请求报文中对应的6个变量</span></span><br><span class="line">        <span class="comment">// 存储读取文件的名称</span></span><br><span class="line">        <span class="built_in">char</span> m_real_file[FILENAME_LEN];</span><br><span class="line">        <span class="built_in">char</span> *m_url;</span><br><span class="line">        <span class="built_in">char</span> *m_version;</span><br><span class="line">        <span class="built_in">char</span> *m_host;</span><br><span class="line">        <span class="built_in">int</span> m_content_length;</span><br><span class="line">        <span class="built_in">bool</span> m_linger;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">char</span> *m_file_address;        <span class="comment">// 读取服务器上的文件地址</span></span><br><span class="line">        <span class="keyword">struct</span> stat m_file_stat;</span><br><span class="line">        <span class="keyword">struct</span> iovec m_iv[<span class="number">2</span>];        <span class="comment">// io向量机制iovec</span></span><br><span class="line">        <span class="built_in">int</span> m_iv_count;</span><br><span class="line">        <span class="built_in">int</span> cgi;                     <span class="comment">// 是否启用的POST</span></span><br><span class="line">        <span class="built_in">char</span> *m_string;              <span class="comment">// 存储请求头数据</span></span><br><span class="line">        <span class="built_in">int</span> bytes_to_send;           <span class="comment">// 剩余发送字节数</span></span><br><span class="line">        <span class="built_in">int</span> bytes_have_send;         <span class="comment">// 已发送字节数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>报文解析流程</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void http_conn::process<span class="literal">()</span> &#123;</span><br><span class="line">    HTTP_CODE read_ret = process<span class="constructor">_read()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO_REQUEST，表示请求不完整，需要继续接收请求数据</span></span><br><span class="line">    <span class="keyword">if</span> (read_ret<span class="operator"> == </span>NO_REQUEST) &#123;</span><br><span class="line">        <span class="comment">// 注册并监听读事件</span></span><br><span class="line">        modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用process_write完成报文响应</span></span><br><span class="line">    <span class="built_in">bool</span> write_ret=process<span class="constructor">_write(<span class="params">read_ret</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!write_ret) &#123;</span><br><span class="line">        close<span class="constructor">_conn()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册并监听写事件</span></span><br><span class="line">    modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>process_read通过while循环，将主从状态机进行封装，对报文的每一行进行循环处理。</p><ul><li><p>判断条件</p></li><li><ul><li>主状态机转移到CHECK_STATE_CONTENT，该条件涉及解析消息体</li><li>从状态机转移到LINE_OK，该条件涉及解析请求行和请求头部</li><li>两者为或关系，当条件为真则继续循环，否则退出</li></ul></li><li><p>循环体</p></li><li><ul><li>从状态机读取数据</li><li>调用get_line函数，通过m_start_line将从状态机读取数据间接赋给text</li><li>主状态机解析text</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m_start_line是行在buffer中的起始位置，将该位置后面的数据赋给text</span></span><br><span class="line"><span class="comment">// 此时从状态机已提前将一行的末尾字符\r\n变为\0\0，所以text可以直接取出完整的行进行解析</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">get_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_read_buf + m_start_line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化从状态机状态、HTTP请求解析结果</span></span><br><span class="line">    LINE_STATUS line_status = LINE_OK;</span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">    <span class="type">char</span>* text=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为什么要写两个判断条件？第一个判断条件为什么这样写？</span></span><br><span class="line">    <span class="comment">// 具体的在主状态机逻辑中会讲解。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse_line为从状态机的具体实现</span></span><br><span class="line">    <span class="keyword">while</span> ((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = <span class="built_in">parse_line</span>()) == LINE_OK)) &#123;</span><br><span class="line">        text = <span class="built_in">get_line</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m_start_line是每一个数据行在m_read_buf中的起始位置</span></span><br><span class="line">        <span class="comment">// m_checked_idx表示从状态机在m_read_buf中读取的位置</span></span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主状态机的三种状态转移逻辑</span></span><br><span class="line">        <span class="keyword">switch</span> (m_check_state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_REQUESTLINE: &#123;</span><br><span class="line">                <span class="comment">//解析请求行</span></span><br><span class="line">                ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">                <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_HEADER: &#123;</span><br><span class="line">                <span class="comment">// 解析请求头</span></span><br><span class="line">                ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">                <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 完整解析GET请求后，跳转到报文响应函数</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_CONTENT: &#123;</span><br><span class="line">                <span class="comment">// 解析消息体</span></span><br><span class="line">                ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 完整解析POST请求后，跳转到报文响应函数</span></span><br><span class="line">                <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析完消息体即完成报文解析，避免再次进入循环，更新line_status</span></span><br><span class="line">                line_status = LINE_OPEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从状态机逻辑：</p><p>在HTTP报文中，每一行的数据由\r\n作为结束字符，空行则是仅仅是字符\r\n。因此，可以通过查找\r\n将报文拆解成单独的行进行解析。从状态机负责读取buffer中的数据，将每行数据末尾的\r\n置为\0\0，并更新从状态机在buffer中读取的位置m_checked_idx，以此来驱动主状态机解析。</p><ul><li><p>从状态机从m_read_buf中逐字节读取，判断当前字节是否为\r</p></li><li><ul><li>接下来的字符是\n，将\r\n修改成\0\0，将m_checked_idx指向下一行的开头，则返回LINE_OK</li><li>接下来达到了buffer末尾，表示buffer还需要继续接收，返回LINE_OPEN</li><li>否则，表示语法错误，返回LINE_BAD</li></ul></li><li><p>当前字节不是\r，判断是否是\n（<strong>一般是上次读取到\r就到了buffer末尾，没有接收完整，再次接收时会出现这种情况</strong>）</p></li><li><ul><li>如果前一个字符是\r，则将\r\n修改成\0\0，将m_checked_idx指向下一行的开头，则返回LINE_OK</li></ul></li><li><p>当前字节既不是\r，也不是\n</p></li><li><ul><li>表示接收不完整，需要继续接收，返回LINE_OPEN</li></ul></li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 从状态机，用于分析出一行内容</span><br><span class="line"><span class="regexp">//</span> 返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> m_read_idx指向缓冲区m_read_buf的数据末尾的下一个字节</span><br><span class="line"><span class="regexp">//</span> m_checked_idx指向从状态机当前正在分析的字节</span><br><span class="line">http_conn::LINE_STATUS http_conn::parse_line() &#123;</span><br><span class="line">    char temp;</span><br><span class="line">    <span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx) &#123;</span><br><span class="line">        <span class="regexp">//</span>temp为将要分析的字节</span><br><span class="line">        temp = m_read_buf[m_checked_idx];</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 如果当前是\r字符，则有可能会读取到完整行</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="regexp">//</span> 下一个字符达到了buffer结尾，则接收不完整，需要继续接收</span><br><span class="line">            <span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx)</span><br><span class="line">                return LINE_OPEN;</span><br><span class="line">            <span class="regexp">//</span> 下一个字符是\n，将\r\n改为\<span class="number">0</span>\<span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                return LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="regexp">//</span> 如果都不符合，则返回语法错误</span><br><span class="line">            return LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 如果当前字符是\n，也有可能读取到完整行</span><br><span class="line">        <span class="regexp">//</span> 一般是上次读取到\r就到buffer末尾了，没有接收完整，再次接收时会出现这种情况</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="regexp">//</span> 前一个字符是\r，则接收完整</span><br><span class="line">            <span class="keyword">if</span> (m_checked_idx &gt; <span class="number">1</span> &amp;&amp; m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">                m_read_buf[m_checked_idx-<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                return LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            return LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> 并没有找到\r\n，需要继续接收</span><br><span class="line">    return LINE_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主状态机逻辑"><a href="#主状态机逻辑" class="headerlink" title="主状态机逻辑"></a><strong>主状态机逻辑</strong></h4><p>主状态机初始状态是CHECK_STATE_REQUESTLINE，通过调用从状态机来驱动主状态机，在主状态机进行解析前，从状态机已经将每一行的末尾\r\n符号改为\0\0，以便于主状态机直接取出对应字符串进行处理。</p><ul><li><p>CHECK_STATE_REQUESTLINE</p></li><li><ul><li>主状态机的初始状态，调用parse_request_line函数解析请求行</li><li>解析函数从m_read_buf中解析HTTP请求行，获得请求方法、目标URL及HTTP版本号</li><li>解析完成后主状态机的状态变为CHECK_STATE_HEADER</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析http请求行，获得请求方法，目标url及http版本号</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在HTTP报文中，请求行用来说明请求类型,要访问的资源以及所使用的HTTP版本，其中各个部分之间通过\t或空格分隔。</span></span><br><span class="line">    <span class="comment">// 请求行中最先含有空格和\t任一字符的位置并返回</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有空格或\t，则报文格式有误</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该位置改为\0，用于将前面数据取出</span></span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出数据，并通过与GET和POST比较，以确定请求方式</span></span><br><span class="line">    <span class="type">char</span> *method = text;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        m_method = GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        m_method = POST;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m_url此时跳过了第一个空格或\t字符，但不知道之后是否还有</span></span><br><span class="line">    <span class="comment">// 将m_url向后偏移，通过查找，继续跳过空格和\t字符，指向请求资源的第一个字符</span></span><br><span class="line">    m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用与判断请求方式的相同逻辑，判断HTTP版本号</span></span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!m_version)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅支持HTTP/1.1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对请求资源前7个字符进行判断</span></span><br><span class="line">    <span class="comment">// 这里主要是有些报文的请求资源中会带有http://，这里需要对这种情况进行单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;http://&quot;</span>,<span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样增加https情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;https://&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        m_url += <span class="number">8</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般的不会带有上述两种符号，直接是单独的/或/后面带访问资源</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当url为/时，显示欢迎界面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(m_url) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(m_url, <span class="string">&quot;judge.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求行处理完毕，将主状态机转移处理请求头</span></span><br><span class="line">    m_check_state = CHECK_STATE_HEADER;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析请求头</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析http请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="type">char</span> *text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是空行还是请求头</span></span><br><span class="line">    <span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是GET还是POST请求</span></span><br><span class="line">        <span class="keyword">if</span> (m_content_length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// POST需要跳转到消息体处理状态</span></span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析请求头部连接字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过空格和\t字符</span></span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是长连接，则将linger标志设置为true</span></span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析请求头部内容长度字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Content-length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_content_length = <span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析请求头部HOST字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;oop!unknow header: %s\n&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析消息体</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断http请求是否被完整读入</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="type">char</span> *text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断buffer中是否读取了消息体</span></span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx)) &#123;</span><br><span class="line"></span><br><span class="line">        text[m_content_length]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// POST请求中最后为输入的用户名和密码</span></span><br><span class="line">        m_string = text;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有限状态机，一种抽象的理论模型。&quot;&gt;&lt;a href=&quot;#有限状态机，一种抽象的理论模型。&quot; class=&quot;headerlink&quot; title=&quot;有限状态机，一种抽象的理论模型。&quot;&gt;&lt;/a&gt;有限状态机，一种抽象的理论模型。&lt;/h2&gt;&lt;p&gt;有限状态机(Finite S</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    <category term="work" scheme="https://serenitylc.github.io/categories/records/work/"/>
    
    
    <category term="fsm" scheme="https://serenitylc.github.io/tags/fsm/"/>
    
  </entry>
  
  <entry>
    <title>RE0</title>
    <link href="https://serenitylc.github.io/2022/07/31/hello-world/"/>
    <id>https://serenitylc.github.io/2022/07/31/hello-world/</id>
    <published>2022-07-31T13:00:00.000Z</published>
    <updated>2022-07-31T14:28:01.298Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="Hexo" scheme="https://serenitylc.github.io/tags/Hexo/"/>
    
    <category term="Butterfly" scheme="https://serenitylc.github.io/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>tmux--terminal multiplexer</title>
    <link href="https://serenitylc.github.io/2022/07/20/tmux/"/>
    <id>https://serenitylc.github.io/2022/07/20/tmux/</id>
    <published>2022-07-19T16:00:00.000Z</published>
    <updated>2022-08-01T13:57:08.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tmux：terminal-multiplexer"><a href="#Tmux：terminal-multiplexer" class="headerlink" title="Tmux：terminal multiplexer"></a>Tmux：terminal multiplexer</h1><h2 id="会话-窗口-窗格"><a href="#会话-窗口-窗格" class="headerlink" title="会话, 窗口, 窗格"></a>会话, 窗口, 窗格</h2><p>根据Tmux的定义，在开启Tmux服务器后，会创建一个会话，该会话会创建一个窗口，其中仅包含一个窗格。Tmux使用C&#x2F;S模型构建，主要包括以下模块：</p><ul><li><strong>server</strong> 服务器：输入 tmux 命令时就开启了一个服务器，服务器由于管理多个会话。</li><li><strong>session</strong> 会话：一个服务器可以包含多个会话，可以理解成是一个特定的终端组合，通常将同一任务下的工作放到一个会话中。</li><li><strong>window</strong> 窗口：一个会话可以包含多个窗口，一个窗口就相当于普通终端的一个标签，通常在不同的窗口中完成不同的工作。</li><li><strong>pane</strong> 窗格：一个窗口可以被分割成多个小的窗格。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用Tmux快捷键需加上命令前缀Ctrl+b。</p><p>Ctrl+b+d 暂时离开当前会话</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p><strong>信息查询:</strong></p></li><li><ul><li>tmux list-keys</li><li>tmux list-commands</li><li>tmux info</li></ul></li><li><p><strong>会话控制:</strong></p></li><li><ul><li>tmux new -s session_name</li><li>tmux attach -t session_name </li><li>tmux switch -t session_name </li><li>tmux rename -t old-name new-name </li><li>tmux list-sessions &#x2F; tmux ls </li><li>tmux detach </li><li>tmux kill-server 关闭所有 session</li></ul></li><li><p><strong>窗口控制:</strong></p></li><li><ul><li>tmux new-window </li><li>tmux list-windows </li><li>tmux select-window -t :0-9 </li><li>tmux rename-window</li></ul></li><li><p><strong>窗格控制:</strong></p></li><li><ul><li>tmux split-window   水平划分</li><li>tmux split-window -h 垂直划分</li><li>tmux swap-pane -[UDLR] 在指定方向交换 pane</li><li>tmux select-pane -[UDLR] 在指定方向选择下一个 pane</li></ul></li><li><p><strong>其他操作:</strong></p></li><li><ul><li>tmux clear-history 清空输出缓冲区</li></ul></li></ul><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p><strong>基本操作</strong></p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>?</td><td>列出所有快捷键；按 q 返回</td></tr><tr><td>d</td><td>脱离当前会话,可暂时返回 Shell 界面</td></tr><tr><td>s</td><td>选择并切换会话；在同时开启了多个会话时使用</td></tr><tr><td>L</td><td>切换回上一次的会话</td></tr><tr><td>D</td><td>选择要脱离的会话；在同时开启了多个会话时使用</td></tr><tr><td>:</td><td>进入命令行模式；此时可输入支持的命令，例如 kill-server 关闭所有tmux会话</td></tr><tr><td>[</td><td>复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q&#x2F;Esc 退出</td></tr><tr><td>]</td><td>进入粘贴模式，粘贴之前复制的内容，按 q&#x2F;Esc 退出</td></tr><tr><td>~</td><td>列出提示信息缓存；其中包含了之前 tmux 返回的各种提示信息</td></tr><tr><td>t</td><td>显示当前的时间</td></tr></tbody></table><p><strong>窗口操作</strong></p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>c</td><td>创建新窗口</td></tr><tr><td>&amp;</td><td>关闭当前窗口</td></tr><tr><td>[0-9]</td><td>数字键切换到指定窗口</td></tr><tr><td>p</td><td>切换至上一窗口</td></tr><tr><td>n</td><td>切换至下一窗口</td></tr><tr><td>l</td><td>前后窗口间互相切换</td></tr><tr><td>w</td><td>通过窗口列表切换窗口</td></tr><tr><td>,</td><td>重命名当前窗口，便于识别</td></tr><tr><td>.</td><td>修改当前窗口编号，相当于重新排序</td></tr><tr><td>f</td><td>在所有窗口中查找关键词，便于窗口多了切换</td></tr></tbody></table><p><strong>窗格操作</strong></p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>“</td><td>将当前面板上下分屏</td></tr><tr><td>%</td><td>将当前面板左右分屏</td></tr><tr><td>x</td><td>关闭当前分屏</td></tr><tr><td>!</td><td>将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</td></tr><tr><td>q</td><td>显示面板编号</td></tr><tr><td>o</td><td>选择当前窗口中下一个面板</td></tr><tr><td>{</td><td>向前置换当前面板</td></tr><tr><td>}</td><td>向后置换当前面板</td></tr><tr><td>z</td><td>最大化当前所在面板</td></tr><tr><td>方向键</td><td>移动光标选择对应面板</td></tr><tr><td>page up</td><td>向上滚动屏幕，q 退出</td></tr><tr><td>page down</td><td>向下滚动屏幕，q 退出</td></tr><tr><td>alt+o</td><td>逆时针旋转当前窗口的面板</td></tr><tr><td>ctrl+o</td><td>顺时针旋转当前窗口的面板</td></tr><tr><td>ctrl+方向键</td><td>以 1 个单元格为单位移动边缘以调整当前面板大小</td></tr><tr><td>alt+方向键</td><td>以 5 个单元格为单位移动边缘以调整当前面板大小</td></tr></tbody></table><h2 id="复制模式（copy-mode）"><a href="#复制模式（copy-mode）" class="headerlink" title="复制模式（copy-mode）"></a>复制模式（copy-mode）</h2><p>Tmux的使用类似于vim，在窗口中要自由的复制文本，可以进入复制模式，使用 prefix + [ 进入复制模式:</p><ul><li>按 space 开始复制，移动光标选择复制区域</li><li>按 Enter 复制并退出 copy-mode。</li><li>将光标移动到指定位置，按 prefix + ] 粘贴</li></ul><p>如果启用鼠标，可以用鼠标选中要复制的文本，prefix + ] 粘贴。</p><p>还可以按住 shift 键，然后再用鼠标选中要复制的文本，此时是系统正常的复制，需要鼠标右键选择复制才能复制文本。在 Mac OSX 上，该快捷功能键是 option.</p><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><h3 id="同步窗格"><a href="#同步窗格" class="headerlink" title="同步窗格"></a>同步窗格</h3><p>在一个窗口下的多个窗格中同时同步执行一个命令操作。需开启 synchronize-panes 配置。进入命令模式 Ctrl-B: 然后输入以下指令开启或关闭窗口同步：</p><p>:setw synchronize-panes on  # 开启窗口同步</p><p>:setw synchronize-panes off # 关闭窗口同步</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>&#x2F;etc&#x2F;tmux.conf 全局配置，～&#x2F;.tmux.conf 用户配置。例如Tmux也可以像vim一样使用底行命令模式，我们重新配置其快捷键跟vim一样使用 :，在配置文件中添加如下内容：</p><p># bind : to command-prompt like vim</p><p># this is the default in tmux already</p><p>bind : command-prompt</p><p>在命令行模式输入tmux 命令执行相关动作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tmux：terminal-multiplexer&quot;&gt;&lt;a href=&quot;#Tmux：terminal-multiplexer&quot; class=&quot;headerlink&quot; title=&quot;Tmux：terminal multiplexer&quot;&gt;&lt;/a&gt;Tmux：termin</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    
    <category term="tmux" scheme="https://serenitylc.github.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>C/C++相关</title>
    <link href="https://serenitylc.github.io/2022/05/20/C:C++%E7%9B%B8%E5%85%B3/"/>
    <id>https://serenitylc.github.io/2022/05/20/C:C++%E7%9B%B8%E5%85%B3/</id>
    <published>2022-05-19T16:00:00.000Z</published>
    <updated>2022-08-02T15:20:47.675Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/pic/images/C++11.png" alt="示例"></p><h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander</p><h1 id="如何解决复杂性？"><a href="#如何解决复杂性？" class="headerlink" title="如何解决复杂性？"></a>如何解决复杂性？</h1><ul><li><p>分解</p><p>人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。</p></li><li><p>抽象</p></li><li><p>更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。</p></li></ul><h1 id="重构关键技法"><a href="#重构关键技法" class="headerlink" title="重构关键技法"></a>重构关键技法</h1><ul><li>静态 → 动态</li><li>早绑定 → 晚绑定</li><li>继承 → 组合</li><li>编译时依赖 → 运行时依赖</li><li>紧耦合 → 松耦合</li></ul><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><p>依赖倒置原则（DIP）</p><ul><li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</li><li>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</li></ul><p>开放封闭原则（OCP）</p><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul><p>单一职责原则（SRP）</p><ul><li>一个类应该仅有一个引起它变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><p>里氏Liskov 替换原则（LSP）</p><ul><li>子类必须能够替换它们的基类(IS-A)。</li><li>继承表达类型抽象。</li></ul><p>接口隔离原则（ISP）</p><ul><li>不应该强迫客户程序依赖它们不用的方法。</li><li>接口应该小而完备。</li></ul><p>优先使用对象组合，而不是类继承</p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><p>封装变化点</p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li></ul><p>针对接口编程，而不是针对实现编程</p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。</li></ul><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><p>默认情况下编译器是以较低的标准来进行编译</p><p>g++ -std&#x3D;c++17 your_file.cpp -o your_program</p><p>容器：存放数据，STL容器是一种class template。</p><p>算法：STL算法是一种function template。</p><p>迭代器：容器与算法之间的胶合剂，共有五种类型，所有STL容器都附带有自己专属的迭代器，原生指针也是一种迭代器。</p><p>仿函数：行为类似函数，可作为算法的某种策略，是一种重载了operator()的class或class template。</p><p>适配器：用来修饰容器或仿函数或迭代器接口。</p><p>空间配置器：负责空间的配置与管理，是一个实现了动态空间配置、空间管理、空间释放的class template。</p><p>static：修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。其生命周期与程序相同，在main函数之前初始化，程序退出时销毁。（无论是局部静态还是全局静态）。此外，static限制了链接属性，被修饰的全局变量只能被包含该定义的文件访问（多文件编译时，隐藏），在C++中还可以实现不同对象之间数据共享。</p><p>volatile：“易变的”，因为访问寄存器要比访问内存单元快,所以编译器一般会作减少存取内存的优化，但可能会读脏数据。当要求使用volatile声明变量值时，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。</p><p>const：防止变量被修改，必须定义时初始化。对于指针又分为顶层和底层，表示指针本身或指向内容的修改。可通过const_cast进行类型转换。（函数的值传递会创建临时变量，不会改变实参，加不加const无影响，即无法重载进行区分）</p><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p><p>1、const_cast：用于将const变量转为非const</p><p>2、static_cast：用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p><p>3、dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p><p>向上转换：指的是子类向基类的转换</p><p>向下转换：指的是基类向子类的转换</p><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p><p>4、reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p><p>引用的本质就是所引用对象的地址。</p><p>C++里面的四个智能指针(防止内存泄漏): auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。unique_ptr 是一种独享被管理对象指针所有权的智能指针。unique_ptr对象包装一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。</p><p>++i 实现：int&amp; int::operator++ () { *this +&#x3D;1；return *this；}</p><p>i++ 实现：const int int::operator (int) { int oldValue &#x3D; <em>this；++（</em>this）；return oldValue；}</p><p>__attribute((constructor))是gcc扩展，标记这个函数应当在main函数之前执行。同样__attribute((destructor))，</p><p>标记函数应当在程序结束之前（main结束之后，或者调用了exit后）执行。</p><p>虚函数表具体是怎样实现运行时多态的?编译器为每一个类维护一个虚函数表，虚函数表是类对象之间共享的，子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的头部存放指向虚函数表的指针，对虚函数指针的地址解引用得到虚函数表的地址。</p><p>不要在构造函数中调用虚函数：因为父类对象会在子类之前进行构造，此时子类部分的成员还未初始化， 因此调用子类的虚函数是不安全的。不要在析构函数中调用虚函数：析构函数在销毁一个对象时，先调用子类析构，再调用基类析构，此时派生类对象的数据成员已经“销毁”，再调用子类虚函数没有意义。智能指针能够帮助我们处理资源泄露、空悬指针、比较隐晦的由异常造成的资源泄露问题。</p><p>类之间的关系</p><p>（1）继承：is a子类继承父类的方法（鹅和鸟的关系）</p><p>（2）组合：has-a整体和部分的关系，整体和部分之间是不可可分离的，它们具有相同的生命周期（鸟和翅膀的关系）</p><p>（3）聚合：contains-a：整体和部分的关系，整体和部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。如员工和公司之间的关系。</p><p>（4）关联：弱关系，双方一般是平等的。如明星和粉丝之间的关系。</p><p>（5）实现：实现是类和接口之间的关系。接口通过纯虚函数来实现。</p><p>（6）依赖： 简单的理解，依赖就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类B的变化会影响到类A。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，为类B作为参数被类A在某个method方法中使用。</p><p>unordered_map是如何解决哈希冲突的</p><p>一个桶中可以放多个元素，元素的关键字相同；也就是通常的链地址法</p><p>unordered_map会维护桶的平均元素数量，会在需要时添加新的桶，以使得load_factor&lt;&#x3D;max_load_factor</p><p>template <class t> struct atomic;</class></p><p>C++11标准从不同的视角看待问题(多线程下访问共享资源&#x2F;数据)：需要同步的总是资源&#x2F;数据，而不是代码。因此C++11对数据进行了更为良好的抽象，引入”原子数据类型”&#x2F;atomic类型，以达到对开发者掩盖互斥锁、临界区的目的。C++11对常见的原子操作进行了抽象，定义出统一的接口，并根据编译选项&#x2F;环境产生平台相关的实现。新标准将原子操作定义为atomic模板类的成员函数，囊括了绝大多数典型的操作——读、写、比较、交换等。通常情况下，内存模型是一个硬件上的概念，表示机器指令（或者将其视为汇编指令）是以什么样的顺序被处理器执行的。现代的处理器并不是逐条处理机器指令的(强顺序的(strong ordered)&#x2F;弱顺序的(weak ordered))。弱顺序的内存模型: 可以进一步挖掘指令中的并行性，提高指令执行的性能。你一会想顺序执行，一会又想“乱序”执行，更有甚者，还想对“乱”的程度分等级……如何提供这种灵活性呢？在C++11标准中，设计者给出的解决方式是让程序员为原子操作指定所谓的内存顺序：memory_order。实际上，atomic类型的其他原子操作接口都有memory_order这个参数，而且默认值都是std::memory_order_seq_cst。顺序一致内存顺序&#x2F;memory_order_seq_cst：全部存取都按照顺序执行(不要重排序指令，不要整什么指令乱序执行，就按照代码的先后顺序执行机器指令)。松散内存顺序&#x2F;memory_order_relaxed：不对执行顺序做任何保证。</p><p>《深入理解C++11 - C++11新特性解析与应用》</p><p>原子操作彻底宣告C++11来到了多线程和并行编程的时代。相对于偏于底层的pthread库，C++通过定义原子类型的方式，轻松地化解了互斥访问共享数据的难题。不过C++也延续了其易于学习难于精通的特性，虽然atomic&#x2F;原子类型使用上较为简单，但其函数接口(原子操作)却可以有不用的内存顺序。C++11从各种不同的平台上抽象出了一个软件的内存模型，并以内存顺序进行描述，以使得想进一步挖掘并行系统性能的程序员有足够简单的手段来完成以往只能通过内联汇编来完成的工作。</p><p>C++11中这些内存顺序相关的设计，主要还是为了从各种繁杂不同的平台上抽象出独立于硬件平台的并行操作。对于我们日常的开发工作，默认的顺序一致内存顺序memory_order_seq_cst足可以应付了，但是开发者想让多线程程序获得更好的性能的话，尤其是在一些弱内存顺序的平台上，比如PowerPC，建立原子操作间的内存顺序还是很有必要的，因为着能带来极大的性能提升，这也是一些弱一致性内存模型平台的优势。但对于并行编程来说，可能最根本的，还是思考如何将大量计算的问题，按需分解成多个独立的、能够同时运行的部分，并找出真正需要在线程间共享的数据，实现为C++11的原子类型。虽然有了原子类型的良好设计，实现这些都可以非常的便捷，但并不是所有的问题或者计算都适合用并行计算来解决，对于不适用的问题，强行用并行计算来解决会收效甚微，甚至起到相反效果。因此在决定使用并行计算解决问题之前，程序员必须要有清晰的设计规划。而在实现了代码并行后，进一步使用一些性能调试工具来提高并行程序的性能也是非常必要的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/pic/images/C++11.png&quot; alt=&quot;示例&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是设计模式&quot;&gt;&lt;a href=&quot;#什么是设计模式&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式&quot;&gt;&lt;/a&gt;什么是设计模式&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    
    <category term="c/c++" scheme="https://serenitylc.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>vim--write once, use anywhere</title>
    <link href="https://serenitylc.github.io/2022/04/20/vim/"/>
    <id>https://serenitylc.github.io/2022/04/20/vim/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-08-02T15:25:17.077Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/pic/images/vim.jpg" alt="示例"></p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">:h option-list</span><br><span class="line"></span><br><span class="line">普通模式是Vim的自然放松状态。从进入插入模式到返回普通模式为止，在此期间输入或删除的任何内容都被当成一次修改。在撤销时如果想拥有更细的粒度，则尽量减少插入模式停留时间。</span><br><span class="line">&lt;CR&gt;  &lt;Esc&gt;o</span><br><span class="line"></span><br><span class="line">i I<span class="regexp">/a A($a)/</span>o(A&lt;CR&gt;) O(ko)</span><br><span class="line">x<span class="regexp">/2x/</span>dw<span class="regexp">/daw/</span>dap<span class="regexp">/diw/</span>d2w<span class="regexp">/2dw/</span>dw.<span class="regexp">/db/</span>dd<span class="regexp">/2dd/</span>d0<span class="regexp">/d$/</span>dt)</span><br><span class="line">. 重复上次修改</span><br><span class="line">&gt;G  从当前行到末尾行统一增加缩进</span><br><span class="line">r R<span class="regexp">/s S(^c$)/</span>c C(c$) caw ciw c2” cc(S)</span><br><span class="line"><span class="regexp">/ n/</span>N */#</span><br><span class="line">y<span class="regexp">/yiw/y</span>t,<span class="regexp">/yy/</span>p</span><br><span class="line">v<span class="regexp">/viw/</span>V<span class="regexp">/ctrl+v(块状选择) y/</span>p<span class="regexp">/d/u</span></span><br><span class="line">ctrl+h<span class="regexp">/w/u</span>  编辑模式下删除前一个字符<span class="regexp">/单词 /</span>当前行</span><br><span class="line"></span><br><span class="line">w<span class="regexp">/W   移到下一个word/</span>WORD开头 </span><br><span class="line">e<span class="regexp">/E   移到下一个word/</span>WORD尾</span><br><span class="line">b<span class="regexp">/B   移到上一个word/</span>WORD开头 </span><br><span class="line">cw/cW</span><br><span class="line">A word ends at a non-word character, such as a “.”, “-” or “)”.</span><br><span class="line">A WORD ends strictly with a white-space. <span class="keyword">This</span> may not be a word in normal sense.</span><br><span class="line"></span><br><span class="line">行间搜索移动 f/F&#123;<span class="keyword">char</span>&#125;  t&#123;<span class="keyword">char</span>&#125;</span><br><span class="line">;<span class="regexp">/, 前进/</span>回退</span><br><span class="line"></span><br><span class="line"><span class="number">0</span><span class="regexp">/$/</span>^  行首<span class="regexp">/行尾/</span>第一个非空白字符</span><br><span class="line"></span><br><span class="line">gg<span class="regexp">/G/</span>ctrl+o 文件首<span class="regexp">/尾/</span>快速返回上一次停留位置</span><br><span class="line">H<span class="regexp">/M/</span>L     屏幕开头<span class="regexp">/中间/</span>结尾</span><br><span class="line">ctrl+u/f    不同模式下上下翻页</span><br><span class="line">zz         将本行置为屏幕中央</span><br><span class="line"></span><br><span class="line">.,$<span class="regexp">/% s/</span>\&lt;pattern\&gt;<span class="regexp">/target/g</span> c n</span><br><span class="line">/pattern &lt;CR&gt; cw target &lt;Esc&gt; n .</span><br><span class="line"></span><br><span class="line">使用ctrl+c/[ 代替esc</span><br><span class="line">Ctrl+r 撤消以前的撤消命令，恢复以前的操作结果。</span><br><span class="line">gi     快速跳转到最后一次编辑的地方并进入插入模式</span><br><span class="line"></span><br><span class="line">:vs/sp filename</span><br><span class="line">:e filename</span><br><span class="line">:ls :b n :bpre :bnext :bfirst :blast :b buffer_name</span><br><span class="line">&lt;ctrl+w&gt; w<span class="regexp">/h/</span>j<span class="regexp">/k/</span>l<span class="regexp">/H/</span>L</span><br><span class="line"></span><br><span class="line">:tabnew filename  gt/gT </span><br><span class="line"></span><br><span class="line">:reg name [a-z] 复制专用寄存器</span><br><span class="line"></span><br><span class="line">”+ p  粘贴系统剪贴板内容</span><br><span class="line"></span><br><span class="line">:e! 重新加载内容，不保存修改</span><br><span class="line"></span><br><span class="line">vim宏 q&#123;reg&#125; 录制  q 停止  @&#123;reg&#125; 回放</span><br><span class="line">全选 + :normal I” 批量操作</span><br><span class="line"></span><br><span class="line">ctrl+n/p 补全单词</span><br><span class="line">ctrl+ x ctrl +f 补全文件名</span><br><span class="line">:ctrl+p 切换上一个命令</span><br><span class="line">vim a.c b.c -O</span><br><span class="line"></span><br><span class="line">:w !sudo tee % &gt; <span class="regexp">/dev/</span><span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">num&lt;Ctrl-a<span class="regexp">/x &gt; 对数字执行增/</span>减，若光标不在数字上，则正向查找并跳转</span><br><span class="line">g~<span class="regexp">/gu/gU</span> 反转大小写<span class="regexp">/转为小写/</span>转为大写</span><br><span class="line">&gt;<span class="regexp">/&lt; 增加缩进/</span>减小缩进</span><br><span class="line"></span><br><span class="line">插入-普通模式是普通模式的一个特例。在此模式中，可以执行一个普通模式命令，执行完后又返回到插入模式。要从插入模式切换到插入-普通模式，可以按 &lt; C-o &gt;</span><br><span class="line"></span><br><span class="line">:h ex-cmd-index</span><br><span class="line">:<span class="string">&#x27;&lt;,&#x27;</span>&gt;normal .    对高亮选区中的每一行执行普通模式下的 . 命令</span><br><span class="line">:%normal A;</span><br><span class="line"></span><br><span class="line">终端快捷键</span><br><span class="line">ctrl+h<span class="regexp">/w/u</span> 删除前一个字符<span class="regexp">/单词 /</span>当前行</span><br><span class="line">ctrl+a<span class="regexp">/e   快速移动到开头/</span>结尾</span><br><span class="line">ctrl+f<span class="regexp">/b 前移/</span>后移</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/pic/images/vim.jpg&quot; alt=&quot;示例&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用操作&quot;&gt;&lt;a href=&quot;#常用操作&quot; class=&quot;headerlink&quot; title=&quot;常用操作&quot;&gt;&lt;/a&gt;常用操作&lt;/h3&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    
    <category term="vim" scheme="https://serenitylc.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>machine-learning</title>
    <link href="https://serenitylc.github.io/2019/10/28/machine-learning/"/>
    <id>https://serenitylc.github.io/2019/10/28/machine-learning/</id>
    <published>2019-10-28T14:29:41.000Z</published>
    <updated>2022-07-31T14:44:02.727Z</updated>
    
    <content type="html"><![CDATA[<p><strong>李航统计学习方法</strong>:</p><ul><li>NFL定律指明，如果我们对要解决的问题一无所知并假设其分布完全随机且平等，那任何算法的预期性能都是相似的。脱离具体问题，空谈‘什么学习算法更好’毫无意义。</li><li>集成学习的精髓在于假设“子分类器”的错误相互独立，随着集成中子分类器的数目上升，集成学习后的”母分类器”的误差将会以指数级别下降，直至为0。假设过于乐观。</li><li>个体学习的准确性和多样性本身就存在冲突，一般的，准确性很高后，要增加多样性就需牺牲准确性。事实上，如何产生并结合好而不同个体学习器，恰是集合学习的研究核心。</li><li>细分集成学习的话，也有两种截然相反的设计思路：<ul><li>思路1：每个子学习器都是弱分类器，在融合后成为一个强力的主体。<br>代表算法：随机森林<br>每个子学习器都是强分类器，融合过程中可能：<ul><li>思路2（强中取强）：选择最强的那一个。<br>代表算法：dynamic classifier selection</li><li>思路3 （公平选择）：一视同仁的对待每个子学习器，融合出一个更强的主体。<br>代表算法：stacking</li></ul></li></ul></li><li>让一堆子学习器集体做决定的缺陷在于低效，容易被平庸的子学习器拖了后腿。而信赖最强者的缺点在于缺乏稳定性，上限可以很高，下限也可以很低。</li><li>频率学派 - Frequentist - Maximum Likelihood Estimation (MLE，最大似然估计)<br>贝叶斯学派 - Bayesian - Maximum A Posteriori (MAP，最大后验估计)</li><li>频率学派相信参数是客观存在的，虽然未知，但不会改变。因此频率学派的方法一直都是试图估计“哪个值最接近真实值”，相对应的我们使用最大似然估计(Maximum Likelihood Estimation)，置信区间(Confidence Level), 和p-value。因此这一切都是体现我们对于真实值估算的自信和可靠度。</li><li>而贝叶斯学派相信参数不是固定的，我们需要发生过的事情来推测参数，这也是为什么总和先验(Prior)及后验(Posterior)过不去，才有了最大后验(Maximum a Posteriori)即MAP。贝叶斯学派最大的优势在于承认未知(Uncertainty)的存在，因此感觉更符合我们的常识“不可知论”。</li><li>偏置的大小度量了神经元产生正(负)激励的难易程度，偏置是不需要正则化的，并且正则化偏置的话会导致欠拟合。</li><li>有隐层时，学习得到的模型中, 所有的隐单元都是相同的<br>没有隐层时, 可以将所有的参数初始化为0</li><li>one-hot编码：<br>稀疏矩阵做矩阵计算，计算方便快捷、表达能力强。过于稀疏时，过度占用资源。</li><li>embedding嵌入层：类似于虚拟出一个关系对当前数据进行映射。<br>在某种程度上，就是用来降维，降维的原理就是矩阵乘法。在卷积网络中，可以理解为特殊全连接层操作，跟1x1卷积核异曲同工。</li><li>embedding的又一个作用：<br>对低维数据进行升维时，可能把一些其他特征放大了，或者把笼统的特征给分开了。同时，这个embedding是一直在学习优化的，使得整个拉近拉远的过程慢慢形成一个良好的观察点。（距离的远近会影响我们的观察效果。同理，低维数据可能包含的特征是非常笼统的，需要不停地拉近拉远来改变我们的感受野，让我们对这幅图有不同的观察点，找出我们要的茬。）</li><li>回想一下为什么CNN层数越深准确率越高，卷积层卷了又卷，池化层升了又升，升了又降，全连接层连了又连。因为我们也不知道它什么时候突然就学到某个有用特征。但是不管怎样，学习都是好事，所以让机器多卷一卷，多连一连，反正错了多少我会用交叉熵告诉你，怎么做才是对的我会用梯度下降算法告诉你，只要给你时间，你迟早会学懂。因此，理论上，只要层数深，只要参数足够，NN能拟合任何特征。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;李航统计学习方法&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFL定律指明，如果我们对要解决的问题一无所知并假设其分布完全随机且平等，那任何算法的预期性能都是相似的。脱离具体问题，空谈‘什么学习算法更好’毫无意义。&lt;/li&gt;
&lt;li&gt;集成学习的精髓在于假</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    
    <category term="ml" scheme="https://serenitylc.github.io/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>algorithm</title>
    <link href="https://serenitylc.github.io/2019/10/24/algorithm/"/>
    <id>https://serenitylc.github.io/2019/10/24/algorithm/</id>
    <published>2019-10-24T13:09:09.000Z</published>
    <updated>2022-08-02T15:24:38.041Z</updated>
    
    <content type="html"><![CDATA[<p><strong>P问题</strong>：能够在多项式时间内解决的决策问题。<br><strong>NP问题</strong>：多项式时间内能够验证的问题称为NP问题。<br><strong>NPC问题</strong>：可以在多项式时间内对问题所有可能的解进行验证,并给出其正确性的问题。目前不能用多项式时间解决，但还不能证明这个问题不能用多项式解决。<br>规约（Reduction）：如果要证明一个问题是NPC问题，则只需要证明他是NP问题，然后找一个你所知道的NPC问题规约到A即可。<br><strong>NP-hard问题</strong>：是指从算法角度比NP还难的问题，指的是所有的NP问题可以通过某个多项式时间的函数规约到这类问题。NP-hard问题不一定是NP问题，因为总有一些NP-hard问题无法在多项式时间判断一个解是否可行。 </p><p>如果<strong>A到B规约</strong>成功，则说明：B至少比A要难，即只要有一个解决B的黑盒子算法，就能解决A问题。<br>故在证明一个问题是NPC问题时，如果掌握的已知NPC问题越多，对于规约越有利。</p><p>一般来说<strong>证明B是NPC</strong>的过程如下：<br>1.证明B是NP问题。<br>2.知道一个已知的NPC问题A。<br>3.给出一个规约过程A规约到B，并证明此规约过程是多项式时间的。<br><img src="/.io//algorithm/1.jpg" alt="示例"><br><img src="/.io//algorithm/2.jpg" alt="示例"><br><strong>独立集</strong>：一个点集，点集中各点没有关系。（点独立）<br><strong>最大独立集</strong>：点的个数最多的独立集。<br>最大独立集 &#x3D;&#x3D; 点的总数 - 最小点覆盖。<br><strong>最小点覆盖</strong>：图中每个边至少一个端点在该点集中的最小点集。（点覆盖所有边)</p><p><img src="/.io//algorithm/3.jpg" alt="示例"></p><p><img src="/.io//algorithm/4.jpg" alt="示例"></p><p><img src="/.io//algorithm/5.jpg" alt="示例"></p><p><img src="/.io//algorithm/6.jpg" alt="示例"></p><p><img src="/.io//algorithm/7.jpg" alt="示例"></p><p>点覆盖规约到集合覆盖：</p><p><img src="/.io//algorithm/8.jpg" alt="示例"></p><p>Boolean satisfiability problem 简称SAT，简单说就是用来判断一组给定的布林函数，是否可以找到一组变数赋值能使其为真。SAT是第一个NP-Complete problem </p><p><img src="/.io//algorithm/9.jpg" alt="示例"></p><p>SAT规约到3-SAT：</p><p><img src="/.io//algorithm/10.jpg" alt="示例"></p><p><img src="/.io//algorithm/11.jpg" alt="示例"></p><p><img src="/.io//algorithm/12.jpg" alt="示例"></p><p><img src="/.io//algorithm/13.jpg" alt="示例"></p><p><img src="/.io//algorithm/14.jpg" alt="示例"></p><p>3-SAT规约到独立集：</p><p><img src="/.io//algorithm/15.jpg" alt="示例"></p><p><img src="/.io//algorithm/16.jpg" alt="示例"></p><p><img src="/.io//algorithm/17.jpg" alt="示例"></p><p><img src="/.io//algorithm/18.jpg" alt="示例"></p><p><img src="/.io//algorithm/19.jpg" alt="示例"></p><p><img src="/.io//algorithm/20.jpg" alt="示例"></p><p>3-SAT规约到点覆盖：</p><p><img src="/.io//algorithm/21.jpg" alt="示例"></p><p><img src="/.io//algorithm/22.jpg" alt="示例"></p><p><img src="/.io//algorithm/23.jpg" alt="示例"></p><p><img src="/.io//algorithm/24.jpg" alt="示例"></p><p><img src="/.io//algorithm/25.jpg" alt="示例"></p><p>哥尼斯堡七桥问题是在寻找一条遍历图中所有边的简单路径，而哈密尔顿的周游世界问题则是在寻找一条遍历图中所有点的基本路径。</p><p>CIRCUIT-SAT规约到SAT</p><p><img src="/.io//algorithm/26.jpg" alt="示例"></p><p>3-SAT规约到有向哈密尔顿回路：</p><p><img src="/.io//algorithm/27.jpg" alt="示例"></p><p><img src="/.io//algorithm/28.jpg" alt="示例"></p><p><img src="/.io//algorithm/29.jpg" alt="示例"></p><p><img src="/.io//algorithm/30.jpg" alt="示例"></p><p>汉密尔顿路径规约到汉密尔顿回路：</p><p><img src="/.io//algorithm/31.jpg" alt="示例"></p><p>汉密尔顿回路规约到汉密尔顿路径：</p><p><img src="/.io//algorithm/32.jpg" alt="示例"></p><p><img src="/.io//algorithm/33.jpg" alt="示例"></p><p>有向汉密尔顿回路规约到无向汉密尔顿回路：</p><p><img src="/.io//algorithm/34.jpg" alt="示例"></p><p><img src="/.io//algorithm/35.jpg" alt="示例"></p><p>无向汉密尔顿回路规约到有向汉密尔顿回路：</p><p><img src="/.io//algorithm/36.jpg" alt="示例"></p><p>图片来自网络。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;P问题&lt;/strong&gt;：能够在多项式时间内解决的决策问题。&lt;br&gt;&lt;strong&gt;NP问题&lt;/strong&gt;：多项式时间内能够验证的问题称为NP问题。&lt;br&gt;&lt;strong&gt;NPC问题&lt;/strong&gt;：可以在多项式时间内对问题所有可能的解进行验证,并给出</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    
    <category term="algorithm" scheme="https://serenitylc.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>考研复试</title>
    <link href="https://serenitylc.github.io/2019/03/09/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"/>
    <id>https://serenitylc.github.io/2019/03/09/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/</id>
    <published>2019-03-09T13:49:02.000Z</published>
    <updated>2022-07-31T14:43:12.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据库</strong></p><ol><li>数据库保护、访问的内容有哪些：<br>利用权限机制和完整性约束防止非法数据进入数据库；<br>提供故障恢复能力和并发访问控制。</li><li>DBA的职责：<br>管理和控制数据库系统。<br>决定数据库中存放信息的内容和结构；<br>决定数据库的存储结构和存取策略；<br>定义数据的安全性要求和完整性约束条件；<br>监控数据库的使用和运行；<br>改进和重构数据库。</li><li>数据库系统和文件系统相比有何特点：<br>共享性高、冗余度小；<br>采用数据模型描述，整体结构化；<br>由数据库管理系统提供数据安全性、完整性，并发访问控制和故障恢复；<br>具有高度的物理独立性和逻辑独立性；</li><li>什么是完整性约束：<br>完整性约束包含实体完整性、参照完整性、用户自定义完整性；用于确保数据库中数据的正确相容。</li><li>DBMS支持哪几种数据模型：</li><li>SQL(Structured query language)的四个组成部分：<br>数据定义语言、查询语言、数据操纵语言、数据控制语言。</li><li>数据库操纵语言举例：<br>即DML，用户可通过它实现对数据库的基本操作。包含增删改查。</li><li>介绍下有哪些应用数据库：<br>桌面型：Access<br>企业型：SQL Server、MYSQL、Oracle</li><li>什么是数据独立性（数据库的两种独立性）：<br>数据独立性包括数据的物理独立性和逻辑独立性。<br>物理独立性指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。即数据在磁盘上怎样存储由DBMS(数据库管理系统)管理，应用程序只处理数据的逻辑结构。当数据的物理存储改变，应用程序不用修改。<br>逻辑独立性指用户的应用程序与数据库的逻辑结构是相互独立的，即当数据库的逻辑结构改变时，用户程序可以不变。</li><li>数据模式：数据库存放数据的模式。以此才能构造复杂的数据结构来建立数据间的联系。<br>1NF：数据库表中字段都是单一属性，不可再分；<br>2NF：不存在非主属性对任一主属性的部分函数依赖；<br>3NF：不存在非主属性对任一主属性的传递函数依赖。<br>BNCF范式：在第三范式的基础上，消除主属性之间的部分函数依赖。</li><li>数据库的关系操作有哪些？各有什么作用？<br>包括查询(query)和插入(insert)、删除(delete)、修改(update)两大部分。<br>查询操作又可以分为选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡儿积等。</li><li>DB并发操作通常带来哪三类问题：<br>丢失修改：当一个事务修改了数据，并且还未提交到数据库时，另一个事务又对同样的数据进行了修改，并且提交到了数据库中。这样，数据库中没有出现第一个事务修改数据的结果，好像这种数据修改丢失了一样。<br>脏读：当一个事务正在访问数据，并对数据进行了修改，且还未提交到数据库时，另一个事务也访问这个数据，且使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。<br>不可重复读：在一个事务内，多次读同一数据。在这个事务还没有结束时，另一个事务也访问同一数据，在第一个事务中的两次读数据之间，由于第二个事务的修改，所读到的数据可能是不一样的。</li><li>两段锁协议：<br>规定所有事务应遵守的规则：<br>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。<br>在释放一个封锁之后，事务不再申请和获得其它任何封锁。<br>即事务的执行分为两个阶段：<br>第一阶段获得封锁，称为扩展阶段。<br>第二阶段释放封锁，称为收缩阶段。</li><li>事务的四个特点：<br>事务：用户定义的一个数据库操作序列，这些操作要么不做要么全做。<br>一致性、原子性、隔离性、持续性。</li><li>数据库故障的种类：<br>事务故障、系统故障、介质故障、计算机病毒。</li><li>数据库恢复策略有哪几种：<br>转储：定期地将数据库中的内容复制到其它存储设备中去。<br>日志：数据库系统创建和维护的用于自动记载数据库中修改型操作的数据更新情况</li><li>数据库的三级模式：<br>外模式、模式、内模式。<br>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。<br>外模式也称子模式（Subschema）或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示。<br>内模式也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。  </li><li>什么是表、什么是视图、两者的区别和联系是什么：<br>表是保存数据的实体，视图是一条语句，不保存数据也没有数据，从表中获取数据。<br>表可以建立各种触发器、索引、主键约束等，但视图无法建立这些对象。表和视图都可以更新，但视图的更新受到约束。</li><li>1NF有哪些缺点：<br>数据冗余太大；更新、插入、删除异常。</li><li>数据字典通常包含五个部分：<br>数据项、数据结构、数据流、数据存储、处理过程。</li><li>数据库中视图的优点：<br>简化用户操作；<br>使用户以不同方式查询同一数据；<br>对数据库重构提供一定程度的逻辑独立性；<br>对机密数据提供安全保护。</li><li>在做数据库开发中使用视图的优点：<br>可以访问表中列的子集，隐藏敏感数据；<br>可以访问表中行的子集，进行条件过滤；<br>可以重命名列名，增加代表意义；<br>可以快速访问多表连接所组成的数据；<br>可以快速读取聚合函数运算返回的数据集；</li><li>数据库的三要素：<br>静态特征（数据结构）、动态特征（数据操作）、完整性约束条件。</li><li>数据库索引：<br>目的：提供多种存储路径，加快查找速度<br>没有查询、统计的需求则不建；数据增删改频繁，系统会花费许多时间维护索引，从而降低查询效率。</li><li>哪些视图可以更新，哪些不可以更新，举例说明：<br>基本表的行列子集视图一般是可更新的；<br>若视图的属性来自聚合函数，表达式，则该视图肯定不可以更新。</li><li>日志文件的定义与作用：<br>定义：用来记录事务对数据库的更新操作的文件；<br>作用：用于数据库恢复，协助后备副本进行介质故障恢复。</li><li>数据库完整性和安全性的区别：<br>前者防止数据库中存在不符合语义的数据，后者防止数据库被恶意破坏和非法存取。</li><li>数据库有哪几种备份策略：<br>完全备份：每次对数据进行完整的备份；<br>增量备份(Incremental Backup)：只备份上次完全备份或增量备份后被修改的文件；<br>差异备份(Differential Backup)：只备份上次完全备份后被修改过的文件。</li><li>什么是数据库控制语言，举例说明：<br>DCL用来设置或更改数据库用户角色权限的语句。<br>包括授权(grant)、拒绝(deny)、删除(remove)</li><li>数据库采用什么机制保证数据库并发操作的正确性：<br>并发控制。相应技术：封锁、时间戳、乐观控制法等。</li><li>数据库安全系统和计算机安全系统的关系：<br>安全性问题并非数据库系统独有，所有计算机系统都有这个问题。只是数据库系统中存放大量数据，并且为许多用户直接共享，从而使安全性问题更为突出。两者是紧密联系、相互支持的关系。</li><li>函数模板和类模板的区别：<br>实例化不同。函数模板的实例化由编译程序在处理函数调用时自动完成，而类模板的实例化必须由程序员在程序中显式指定</li><li>数据库管理系统的完整性要完成的功能：<br>防止不符合语义的数据进入数据库，造成无效操作和错误结果。</li><li>DBMS控制管理功能：<br>数据定义；数据操纵；数据库运行管理；数据库组织和存储；数据库建立和维护。</li><li>DBMS的控制操作有哪些：<br>数据的安全性保护、数据的完整性检查、并发控制、数据恢复。</li><li>数据库两级映像的作用：<br>外模式&#x2F;模式映像：保证数据库中的数据具有较高逻辑独立性；<br>模式&#x2F;内模式映像：保证数据库中的数据具有较高物理独立性；</li><li>笛卡尔积：<br>又称直积，X×Y，第一个对象是X的成员而第二个对象是Y的一个成员所构成的所有可能有序对。</li><li>数据库中的primary key约束和unique约束有何区别：<br>主键约束：标识数据库记录唯一性，针对主键列，不允许记录重复，且键值不为空<br>UNIQUE KEY：防止数据插入时重复，只针对非主键列，允许有空值。</li></ol><p><strong>计算机网络</strong></p><ol><li>比较TCP与UDP：</li><li>网络协议的三个核心要素及作用：</li><li>解释网络体系结构，其实现和理论有何区别：</li><li>波特和比特的区别：</li><li>什么是网络时延：</li><li>什么是码元、码元长度：</li><li>结合Internet，说说有连接服务和无连接服务：</li><li>点对点和端到端工作在哪层，及其工作机制：</li><li>网络时延由哪几部分组成，各产生于何处：</li><li>实体，协议：</li><li>TCP&#x2F;IP网络协议的核心是什么，如何引出“over everything”和“everything over”：</li><li>用白军和蓝军解释下没有100%可靠的通信：</li><li>电路交换与分组交换的区别：</li><li>DNS：</li><li>NAT；</li><li>数据链路层协议分类：</li><li>路由器的组成：内部构件和外部构件；</li><li>IPV4和IPV6的区别：</li><li>TCP的拥塞控制与流量控制的功能与区别：<br>拥塞控制：防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，涉及到所有主机、路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制：指点对点通信量的控制，是端到端的问题。流量控制就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>PPP协议：<br>即点到点协议，运用在数据链路层，支持全双工的同、异步链路上进行点到点的传输，主要由链路控制协议族(LCP)和网络控制协议族(NCP)组成。</li><li>P2P网络编程的特点：<br>P2P对等网络，是一种有别于传统C&#x2F;S架构的分布式网络，用户不必连接到服务器区浏览下载文件，而是寻找对等节点建立网络连接，直接进行数据传输。</li><li>DNS的递归查询和迭代查询（区别）：<br>递归查询：DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。<br>迭代查询：DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。</li><li>ARP协议的过程：<br>即地址解析协议，是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</li><li>计算机网络的接入类型有哪些：<br>局域网、城域网、广域网、互联网</li><li>中继器、集线器、交换机、网桥、网关、路由器的功能作用，区别是什么：<br>(集线器、路由器和交换机有何区别)<br>(集线器、交换机、路由器各工作在哪层)<br>中继器：物理层，简单的信号放大器；<br>集线器：物理层，用于信号放大和连接多个终端；<br>交换机：数据链路层，有多个端口以连接各个主机，使用物理地址(MAC)，转发数据较快；<br>网桥：数据链路层，将两个局域网连起来，根据MAC地址来转发数据帧；<br>网关：网络层以上实现网络互连，是连接两个不同网络的接口；<br>路由器：网络层，阻止广播，安全性高，是用逻辑地址(IP)，转发数据较慢。</li><li>IP和MAC特点：<br>MAC地址存放在MAC帧首部，是数据链路层和物理层使用的地址；<br>IP地址存放在IP数据报的首部，IP数据报是MAC帧的数据，IP是网络层及以上各层使用的地址，是一种逻辑地址。</li><li>多路复用与多路分解：<br>多路复用：从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层；<br>多路分解：将运输层报文段中的数据交付到正确的套接字。</li><li>计算机网络接入方式？举例说明：<br>电话线(ADSL接入)；<br>有线电视网(光纤同轴混合接入(HFC))；<br>无线的WiFi接入；<br>光纤接入(FTTX)。</li><li>什么是虚电路网络，什么是数据报网络：<br>虚电路网络：两个通信主机在通信之前事先建立一条通道线路，所有分组都将沿这条线路有序传输。但这个线路上的某个路由器或者链路也可以为其他用户进行服务；<br>数据报网络：将要发送的数据分为许多分组进行独立发送，在发送过程中各个分组各自走自己的路线。</li><li>简述C&#x2F;S和P2P混合结构的特点：<br>网络上每台主机既是服务器又是客户端。</li><li>公司配置域名服务器，该如何配置：<br>代理商注册域名，域名申请成功后做域名解析，绑定IP地址。</li><li>计算机网络有哪几种校验算法：<br>循环冗余校验CRC，奇偶校验，海明码校验。</li><li>子网掩码和默认网关是什么及作用：<br>子网掩码是一个32位地址，用于将某个IP地址划分为网络地址和主机地址两部分，可判断任意两台计算机的IP地址是否属于同一子网络；<br>默认网关是一个用于 TCP&#x2F;IP 协议的配置项，是一个可直接到达的 IP 路由器的 IP 地址。一台主机若找不到可用网关，就把数据包发给指定的默认网关，由这个网关来处理数据包。</li><li>网络中数据的分片与重组发生在何时：<br>(IP协议在传输数据包时会将数据报文分成若干片进行传输，并在目标系统中进行重组。)<br>如果IP数据报加上数据帧头部后大于MTU，数据报文就会分成若干片进行传输。<br>在目标系统中具有同一个ID的IP分片将会从新组装，直到接收所有片段，形成正确的顺序。</li><li>如何实现IPV4和IPV6的互通：<br>双IP层技术：保持IPv6与IPv4互操作性的最直接方式。适用于Internet由IPv4向IPv6过渡的前期。具有双IP层的节点成为IPv4&#x2F;IPv6节点。它具有两个IP协议的完整实现。<br>隧道技术：适用于Internet由IPv4向IPv6过渡的中期。其原理是两个IPv6的网络之间的中间网络的多协议路由器接收到源主机的IP包时，将其放入中间网络层数据包在和域中，当其到达中间网络另一端多协议路由器时再恢复源IP包并转发到目的主机。<br>报头翻译技术：当Internet中只有极少数IPv4节点时（过渡阶段后期），报头翻译技术可以保持IPv6与IPv4节点间的通讯。向IPv4节点发送消息时，路径上最后一个IPv6&#x2F;IPv4路由器发现目的地址是IPv4映射地址则进行报头翻译，将IPv6报头替换成IPv4报头，并转发到目的IPv4节点。</li><li>UDP和TCP套接字编程的区别：<br>UDP程序结构更简单，对系统资源的要求更少；<br>TCP保证数据正确性，UDP可能丢包；<br>TCP保证数据顺序，UDP不保证。</li><li>发送序号和确认序号的作用：<br>发送方发送序号作为数据包的唯一标示，保证了传输数据包的顺序，同时接收方通过确认序号来保证所有传输的数据按照正常顺序重组，从而保障数据传输的完整。</li><li>TCP建立连接：即三次握手。<br>第一次握手：客户端发送同步包到服务器；<br>第二次握手：服务器收到同步包，必须确认客户的同步请求，同时也发送一个同步确认包（ask&#x3D;k）；<br>第三次握手：客户端收到服务器的同步确认包，向服务器发送确认包。三次握手完成后，客户端和服务器就建立了tcp连接。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库保护、访问的内容有哪些：&lt;br&gt;利用权限机制和完整性约束防止非法数据进入数据库；&lt;br&gt;提供故障恢复能力和并发访问控制。&lt;/li&gt;
&lt;li&gt;DBA的职责：&lt;br&gt;管理和控制数据库系统。&lt;br&gt;决定数据</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    
    <category term="cs" scheme="https://serenitylc.github.io/tags/cs/"/>
    
  </entry>
  
  <entry>
    <title>golden-age</title>
    <link href="https://serenitylc.github.io/2018/11/20/golden-age/"/>
    <id>https://serenitylc.github.io/2018/11/20/golden-age/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2022-07-31T14:43:35.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="已是去时独自语，欲语还休❤"><a href="#已是去时独自语，欲语还休❤" class="headerlink" title="已是去时独自语，欲语还休❤"></a>已是去时独自语，欲语还休❤</h2><blockquote><p>　　大学是一片梦中海，我们从不同的河游入其中，带着向往，带着好奇，也带着未知。 </p></blockquote><blockquote><p>　　曾几何时，这玩意儿在耳边响起，便一刻也没消停，牛鬼蛇神皆如此言，说者意味深长，听者不以为意。因缘巧合，有的人来了，有的人没有。至者片刻欢喜，不至者片刻忧伤，但所思所想遂变。总的来说，人可以适应任何一种气氛，虽然需要一点时间。正如每个人都有自己的命运，你别无选择。 我们仅是海中鱼，所见所经历便印在心里。我也不知何因到了这里，茫茫大海，也遇见了形形色色的人，真真假假，不觉时间也在喧嚣声中走过。<br>这是个人欲横流的社会，无奇不有，故无足为奇。在这样的大家庭里，大家抬头不见低头见，总会有许多共同的想法。我们总说人艰不拆，但每个人又总觉得自己亏，而别人都欠揍，于是我们怀着一个善良的愿望，就是盼天上掉下个大磨盘，把自己剩在磨眼里，把别人都砸死。虽然我们也常常感到累，有的人累的久了，便把它当做幸福，然后享受它并视为生活，但也并非所有人都能如此。我们都站在一个迷宫面前，前面有很多的线索，很多岔路，谁也看不清什么，偏又总以为无所不知。少一点恶意，多一点诗意，大学的存在，不过是等待故事的开始和讲故事的人而已。曲终人散。 </p></blockquote><blockquote><p>　　四年时间里，零零碎碎学了一些东西，却好像丢下了更多，不知学为何。其实我觉得学习并非他人所授，也非社会所求，此乃本能，如同成长一般，我们都该做自己的老师。能力强弱，影响甚多，想或不想，无足轻重，毕竟我们都只是一条小小的鱼，离不开的是水，不是大海。君主想主宰众生，圣人想拯救百姓。有的话做得说不得。明心见性，我思故我在。我们的存在乃是不争事实，其本身便有极大魅力，无需任何证明。正如深山里花开，龙竹笋剥剥地爆去笋壳，直翘翘地向上。 我也时常害怕未知，但是每天清晨醒来不都是新的一天，新的未知吗？因为有的时候我感觉是梦，所以四年里给大家留下了什么印象，现在也不负责任，梦里梦外不知谁更怪！ 尘世嚣嚣，我们不管做什么，都困难重重。以后如何，无人知晓。这是一个梦，一个故事，要慢慢渗透。</p></blockquote><blockquote><p>最后摘一段话：</p><blockquote><p>天色微微向晚，天上飘着懒洋洋的云彩。下半截沉在黑暗里，上半截仍浮在阳光中。那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。<br>生活，不该如此；生活，正是如此.</p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;已是去时独自语，欲语还休❤&quot;&gt;&lt;a href=&quot;#已是去时独自语，欲语还休❤&quot; class=&quot;headerlink&quot; title=&quot;已是去时独自语，欲语还休❤&quot;&gt;&lt;/a&gt;已是去时独自语，欲语还休❤&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;　　大学是一片梦中海，我们</summary>
      
    
    
    
    <category term="life" scheme="https://serenitylc.github.io/categories/life/"/>
    
    
    <category term="think" scheme="https://serenitylc.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>git分布式(同步)版本控制系统</title>
    <link href="https://serenitylc.github.io/2017/11/20/git/"/>
    <id>https://serenitylc.github.io/2017/11/20/git/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2022-08-01T13:56:31.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git简述"><a href="#Git简述" class="headerlink" title="Git简述"></a>Git简述</h3><ul><li>Git 只关心文件数据的整体是否发生<strong>变化</strong>，而大多数其他系统则只关心文件内容的具体差异。</li><li>保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将结果作为数据<strong>唯一标识和索引</strong>。</li><li>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符(0-9 及 a-f)组成。所有保存在 Git 数据库中的内容都用此<strong>哈希值作索引</strong>，而不是靠文件名。</li><li>任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</li><li>Git 基本流程：<ul><li>在工作目录中修改某些文件。</li><li>对修改后的文件进行快照，然后保存到暂存区域。</li><li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录。</li></ul></li></ul><p>查看配置信息</p><pre><code>$ git config --list</code></pre><p>获取帮助</p><pre><code> $ git help &lt;verb&gt; $ git &lt;verb&gt; --help $ man git-&lt;verb&gt;</code></pre><p>对现有的某个项目开始用 Git 管理，只需到此项目所在的目录初始化：</p><pre><code>$ git init</code></pre><p>如果当前目录下有几个文件想要纳入版本控制，先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><pre><code>$ git add *.c # 加文件名表示跟踪$ git add README$ git commit -m &#39;initial project version&#39;</code></pre><p>克隆仓库：<br>    git clone [url]<br>    $ git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git</p><p>检查当前文件状态：(工作目录的所有文件都不外乎两种状态：已跟踪或未跟踪。)</p><pre><code>$ git statusOn branch masternothing to commit, working directory clean</code></pre><p><code>git add</code> ：根据目标文件的状态不同，此命令的效果也不同。可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。</p><h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>有些文件无需纳入 Git 管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> cat .gitignore</span><br><span class="line"><span class="comment">*.[oa]</span></span><br><span class="line"><span class="comment">*~</span></span><br></pre></td></tr></table></figure><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（&#x2F;）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ul><p>例子：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 此为注释 – 将被 Git 忽略</span></span><br><span class="line"><span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">*<span class="string">.a</span></span><br><span class="line"><span class="comment"># 但 lib.a 除外</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*<span class="string">.txt</span></span><br><span class="line"><span class="comment"># ignore all .txt files in the doc/ directory</span></span><br><span class="line">doc/**/*<span class="string">.txt</span></span><br></pre></td></tr></table></figure><p>查看尚未暂存的文件更新了哪些部分，不加参数直接输入 </p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span></span><br></pre></td></tr></table></figure><p>查看已经暂存起来的文件和上次提交时的快照之间的差异</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span> <span class="literal">--cached</span></span><br></pre></td></tr></table></figure><p>提交更新(先<code>git status</code>看是否都暂存了)：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span> <span class="comment">#说明</span></span><br></pre></td></tr></table></figure><p>在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，<code>Git</code> 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤.</p><h3 id="移除文件："><a href="#移除文件：" class="headerlink" title="移除文件："></a>移除文件：</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code></p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 <code>.gitignore</code> 文件中补上，用 <code>--cached</code> 选项即可：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> <span class="literal">--cached</span> readme.txt</span><br></pre></td></tr></table></figure><p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log&#x2F; 目录下扩展名为 .log 的文件。类似的比如：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> \*~</span><br></pre></td></tr></table></figure><p>会递归删除当前目录及其子目录中所有 ~ 结尾的文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><pre><code>$ git mv file_from file_to</code></pre><p>其实，运行 git mv 就相当于运行了下面三条命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">mv</span> README.txt README</span><br><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> README.txt</span><br><span class="line"><span class="variable">$</span> git add README</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config  查看 git config 的相关命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gitk  图形化查看分支演变</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config merge.tool vimdiff 使用 git mergetool</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;Your Name&quot;</span>配置所有Git仓库的用户名和email, 去掉--global 则只针对当前Git仓库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name   查看全局配置的用户名和email</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init   把当前目录初始化为git仓库, 不想管理跟踪的文件, 可以在仓库根目录添加.gitignore文件, 在里面写对应规则</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span>&lt;repo&gt;自动把本地master分支和远程master分支对应, 远程仓库默认名称origin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add &lt;file&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin git@github.com:serenity/test.git  关联远程仓库 (先有本地仓库)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote   查看远程库信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v   查看远程库详细信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote <span class="built_in">rm</span> origin   删除已关联的远程库 origin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u origin &lt;branch&gt;   推送本地branch分支到远程, -u绑定本地分支与远程分支，首次推送时加，后续简写为git push/pull</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin dev  推送本地dev分支到远程库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=origin/dev devgit pull提示no tracking information，说明本地dev分支和远程dev分支的链接关系没有创建</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reflogreference logs（引用日志），恢复本地错误操作</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD@&#123;1&#125;回退到指定提交</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard &lt;commit_id&gt;</span></span><br><span class="line">所有引起HEAD指针变动的操作，都会被记录在git reflog命令中。如以下操作：</span><br><span class="line">* git checkout branchName：切换分支 。</span><br><span class="line">* git commit：提交。</span><br><span class="line">* git reset commit：重置。</span><br><span class="line">* git checkout commit：签出某一个提交。</span><br><span class="line">* git merge：合并操作。</span><br><span class="line">* git rebase：变基。</span><br><span class="line">* git pull：相当于 fetch + merge 。 merge 结果能够体现出时间线, rebase 会打乱时间线。</span><br><span class="line">* git pull : Fast-forward：没有冲突，快速前进。合并分支时不会创建新的commit，所以看不出来曾经做过合并。</span><br><span class="line">* git pull --rebase：相当于fetch + rebase。</span><br><span class="line">* git clone：初始化ref 。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge dev   合并 dev 分支到当前分支 (当有冲突的时候, 需要先解决冲突)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev 合并 dev 分支到当前分支(--no-ff 以普通模式合并，强行关闭 Fast forward 合并策略，创建一个新的 commit)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --abort撤销本次merge</span></span><br><span class="line"></span><br><span class="line">丢弃工作区 (Working Directory) 的修改</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore &lt;file&gt;  建议使用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- &lt;file&gt;</span></span><br><span class="line"> </span><br><span class="line">丢弃暂存区 (stage/index) 的修改</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore --staged &lt;file&gt;第一步: 把暂存区的修改撤销掉(unstage), 重新放回工作区</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore &lt;file&gt; 第二步: 撤销工作区的修改</span></span><br><span class="line"> </span><br><span class="line">一个本地库关联多个远程库, 如同时关联 GitHub 和 Gitee</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add github git@github.com:serenity/test.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add gitee git@gitee.com:serenity/test.git</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch               查看分支列表及当前分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v            查看各个分支最后一个提交信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -r            查看远程分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -a            查看所有本地和远程分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch dev           创建 dev 分支，本地新建的分支如果不推送到远程，对其他人就是不可见的</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d dev                   删除 dev 分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -D dev                   强制删除 dev 分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=origin/dev dev  指定本地 dev 分支与远程 origin/dev 分支的链接</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git switch dev / git checkout dev            切换到dev分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git switch -c dev / git checkout -b dev      创建并切换到新的dev分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git switch -c dev origin/dev / git checkout -b dev origin/dev创建并切换到新的dev分支，同时关联本地dev分支和远程dev分支</span></span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff commitID1 commitID2  commit 比较</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff / git diff -- &lt;文件名&gt;    工作区和暂存区比较</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff remotes/origin/master工作区与远程分支比较</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --cached         ⽐较暂存区和上⼀次commit后的修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD            暂存区恢复成 HEAD</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- &lt;文件名&gt;       工作区恢复成暂存区文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;分支名&gt;   删除远程分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -r -n --cached .vscode   展示此命令要删除的文件列表预览</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> -r --cached  .vscode      删除远程仓库和git仓库(暂存区和版本库)的文件(夹)，本地目录下的文件(夹)不受影响</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --graph      查看分支合并图</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> dev ^master 查看 dev 有，而 master 中没有的</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> master..dev 查看 dev 中比 master 中多提交了哪些内容</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash  保存当前工作区和暂存区的修改状态（将目前还不想提交但已修改的内容保存至堆栈，后续可以在某个分支上恢复出堆栈中的内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash list      查看保存现场的列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash pop       恢复的同时把 stash 内容也删除</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash apply      恢复现场, stash 内容并不删除</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash drop       删除 stash 内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash apply stash@&#123;0&#125;  多次 stash, 恢复的时候, 先用git stash list查看, 然后恢复指定的 stash</span></span><br><span class="line">                     </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cherry-pick &lt;commit&gt; 复制一个特定的提交到当前分支(当前分支的内容需要先 commit, 然后冲突的文件需要解决冲突, 然后 commit)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase  把本地未push的分叉提交历史整理成直线(使得我们在查看历史提交的变化时更容易, 因为分叉的提交需要三方对比)</span></span><br><span class="line"> </span><br><span class="line">切换到对应的分支 branch 上, 查看或者操作对应的标签 tag</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag               查看所有的标签</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag &lt;tagname&gt;         打标签，默认标签是打在最新提交的commit上(绑定)，如: git tag v1.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag &lt;tagname&gt; &lt;commit_id&gt;   给对应的 commit_id 打标签</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a &lt;tagname&gt; -m <span class="string">&quot;标签说明信息&quot;</span> &lt;commit_id&gt;    创建带有说明的标签，用-a指定标签名，-m指定说明文字</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d &lt;tagname&gt;          删除一个本地标签</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/&lt;tagname&gt; 删除一个远程标签</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show &lt;tagname&gt;  查看标签信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin &lt;tagname&gt;  推送一个本地标签到远程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags     一次性推送全部尚未推送到远程的本地标签</span></span><br><span class="line">删除远程标签, 需要先删除本地标签, 然后在删除远程标签, 如:删除标签 v0.9</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v0.9</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/v0.9</span></span><br><span class="line"></span><br><span class="line">git config core.ignorecase false配置本地仓库文件大小写敏感</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Git简述&quot;&gt;&lt;a href=&quot;#Git简述&quot; class=&quot;headerlink&quot; title=&quot;Git简述&quot;&gt;&lt;/a&gt;Git简述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Git 只关心文件数据的整体是否发生&lt;strong&gt;变化&lt;/strong&gt;，而大多数其他系统则只关心文件</summary>
      
    
    
    
    <category term="records" scheme="https://serenitylc.github.io/categories/records/"/>
    
    
    <category term="git" scheme="https://serenitylc.github.io/tags/git/"/>
    
  </entry>
  
</feed>
